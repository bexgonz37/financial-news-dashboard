<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <!-- Environment variables -->
  <script src="public/env.js"></script>
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>🚀 PRO Day Trader Dashboard - Advanced News & Screener</title>
  <!-- LEGAL DISCLAIMER: This is for educational/entertainment purposes only. Not financial advice. -->
  <style>
    :root{
      --bg:#0b0f17; --card:#1a2132; --border:#20273a; --text:#e6e8ee; --meta:#8b9bb4;
      --accent:#b167ff; --up:#24e39c; --down:#ff5b6e; --loading:#4a5568
    }
    *{ box-sizing:border-box; margin:0; padding:0 }
    body{ background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif; line-height:1.6 }
    .container{ max-width:1400px; margin:0 auto; padding:20px }
    .header{ display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:30px }
    .header-left{ flex:1; text-align:left }
    .header-right{ display:flex; flex-direction:column; align-items:flex-end; gap:8px }
    .health-panel{ display:flex; gap:12px; padding:8px 12px; background:var(--card); border:1px solid var(--border); border-radius:8px; font-size:0.8rem }
    .status-indicator{ font-weight:600; padding:4px 8px; border-radius:6px; font-size:0.75rem; transition:all 0.3s ease }
    .status-indicator.live{ background:rgba(36,227,156,0.2); color:var(--up); box-shadow:0 0 8px rgba(36,227,156,0.3) }
    .status-indicator.degraded{ background:rgba(255,193,7,0.2); color:#ffc107; box-shadow:0 0 8px rgba(255,193,7,0.3) }
    .status-indicator.offline{ background:rgba(255,91,110,0.2); color:var(--down); box-shadow:0 0 8px rgba(255,91,110,0.3) }
    .header h1{ font-size:2.5rem; font-weight:900; margin-bottom:10px; background:linear-gradient(135deg,var(--accent),var(--up)); -webkit-background-clip:text; -webkit-text-fill-color:transparent }
    .header p{ color:var(--meta); font-size:1.1rem }
    .status-bar{ display:flex; align-items:center; gap:8px; padding:4px 8px; border-radius:4px; background:rgba(0,255,0,0.1); border:1px solid rgba(0,255,0,0.3); font-size:0.8rem }
    .status-indicator{ color:#00ff00; font-size:0.6rem }
    .status-bar.degraded{ background:rgba(255,193,7,0.1); border-color:rgba(255,193,7,0.3) }
    .status-bar.degraded .status-indicator{ color:#ffc107 }
    .status-bar.error{ background:rgba(255,0,0,0.1); border-color:rgba(255,0,0,0.3) }
    .status-bar.error .status-indicator{ color:#ff0000 }
    .tabs{ display:flex; gap:2px; background:var(--card); padding:4px; border-radius:12px; margin-bottom:20px; border:1px solid var(--border) }
    .tab{ flex:1; padding:12px 20px; background:transparent; border:none; color:var(--text); cursor:pointer; border-radius:8px; transition:all 0.2s; font-weight:500 }
    .tab:hover{ background:rgba(177,103,255,.1) }
    .tab.active{ background:var(--accent); color:#fff; font-weight:600 }
    .panel{ display:none }
    .panel.active{ display:block }
    .toolbar{ display:flex; gap:10px; margin-bottom:20px; flex-wrap:wrap; align-items:center }
    .input{ padding:10px 14px; border:1px solid var(--border); border-radius:8px; background:var(--card); color:var(--text); font-size:.9rem; min-width:200px }
    .input:focus{ outline:none; border-color:var(--accent) }
    .btn{ padding:10px 20px; background:var(--accent); color:#fff; border:none; border-radius:8px; cursor:pointer; font-weight:500; transition:all 0.2s }
    .btn:hover{ background:#9a5ce0; transform:translateY(-1px) }
    .select{ padding:10px 14px; border:1px solid var(--border); border-radius:8px; background:var(--card); color:var(--text); font-size:.9rem; min-width:150px }
    .grid{ display:grid; grid-template-columns:repeat(auto-fill,minmax(300px,1fr)); gap:16px }
    .card{ background:var(--card); border:1px solid var(--border); border-radius:12px; padding:16px; transition:all 0.3s ease; box-shadow:0 2px 8px rgba(0,0,0,0.1) }
    .card:hover{ border-color:var(--accent); transform:translateY(-2px); box-shadow:0 4px 16px rgba(0,0,0,0.2) }
    .kpi{ display:flex; justify-content:space-between; align-items:center; margin-bottom:12px }
    .change{ font-weight:700; font-size:1.1rem }
    .change.up{ color:var(--up) }
    .change.down{ color:var(--down) }
    .meta{ color:var(--meta); font-size:.85rem }
    .loading{ text-align:center; padding:40px; color:var(--loading); font-size:1.1rem }
    
    /* Day Trader Filter Styling */
    .filter-checkbox{ 
      display:flex; 
      gap:8px; 
      align-items:center; 
      color:var(--text); 
      font-size:.9rem;
      padding: 8px 12px;
      border-radius: 8px;
      background: rgba(177,103,255,.05);
      border: 1px solid rgba(177,103,255,.1);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .filter-checkbox:hover{ 
      background: rgba(177,103,255,.1);
      border-color: rgba(177,103,255,.2);
    }
    .filter-checkbox input[type="checkbox"]:checked + .filter-label{ 
      color: var(--accent);
      font-weight: 600;
    }
    .filter-label{ 
      cursor: pointer;
      user-select: none;
    }

    .news-list{ display:grid; gap:12px }
    .news-item{ border:1px solid var(--border); border-radius:12px; padding:16px; background:linear-gradient(180deg, rgba(32,39,58,.6), rgba(18,24,38,.9)); transition:all 0.3s ease; box-shadow:0 2px 8px rgba(0,0,0,0.1) }
    .news-item:hover{ border-color:var(--accent); transform:translateY(-2px); box-shadow:0 4px 16px rgba(0,0,0,0.2) }
    .item-top{ display:flex; align-items:center; gap:12px; margin-bottom:8px; flex-wrap:wrap }
    .ticker{ color:var(--accent); font-weight:700; text-decoration:none; font-size:1.1rem }
    .ticker:hover{ text-decoration:underline }
    .title{ font-weight:600; margin-bottom:6px; line-height:1.4 }
    .summary{ color:var(--meta); font-size:.9rem; line-height:1.5 }
    .summary a{ color:var(--up); text-decoration:none }
    .summary a:hover{ text-decoration:underline }
    .read-btn{ 
      background: var(--accent); 
      color: white; 
      border: none; 
      padding: 4px 8px; 
      border-radius: 4px; 
      font-size: 0.8rem; 
      cursor: pointer; 
      margin-left: 8px;
      transition: all 0.2s ease;
    }
    .read-btn:hover{ 
      background: var(--up); 
      transform: translateY(-1px);
    }
    .mini-row{ display:flex; justify-content:space-between; align-items:center; margin-top:10px }
    .mini-chart{ 
      width:120px; 
      height:40px; 
      min-width:120px;
      min-height:40px;
      background:var(--bg); 
      border-radius:6px; 
      border:1px solid var(--border);
      cursor:pointer;
      transition:all 0.2s;
      position:relative;
      overflow:hidden;
    }
    .mini-chart:hover{
      border-color:var(--accent);
      transform:scale(1.05);
      box-shadow:0 4px 12px rgba(0,0,0,0.3);
    }
    
    .badge{
      font-size:0.7rem;
      padding:2px 6px;
      border-radius:3px;
      font-weight:bold;
      margin-left:4px;
    }
    .badge.new{
      background:var(--up);
      color:white;
    }
    .badge.changed{
      background:var(--accent);
      color:white;
    }
    
    .session-info{
      display:flex;
      gap:8px;
      margin:4px 0;
      font-size:0.8rem;
    }
    .session.after-hours{
      color:var(--accent);
      font-weight:bold;
    }
    .session.regular{
      color:var(--up);
      font-weight:bold;
    }
    .data-age{
      color:var(--text-muted);
    }
    
    .metric .value.overbought{
      color:var(--down);
      font-weight:bold;
    }
    .metric .value.oversold{
      color:var(--up);
      font-weight:bold;
    }
    .metric .value.up{
      color:var(--up);
    }
    .metric .value.down{
      color:var(--down);
    }
    .metric .value.score{
      color:var(--accent);
      font-weight:bold;
    }
    .metric .value.ai-score{
      color:var(--up);
      font-weight:bold;
      background:linear-gradient(45deg, var(--up), var(--accent));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
    }
    .mini-chart svg{
      width:100%;
      height:100%;
    }
    .star{ background:none; border:none; color:var(--meta); cursor:pointer; font-size:1.2rem; transition:all 0.2s }
    .star:hover{ color:var(--accent) }
    .star.active{ color:var(--up) }
    .pct{ display:flex; align-items:center; gap:4px; font-weight:600 }
    .arrow{ font-size:1.1rem }
    .after-hours{ color: #ff9800; font-weight: bold; }
    .live{ color: #4caf50; font-weight: bold; }
    .val{ font-size:.9rem }
    .val.up{ color:var(--up) }
    .val.down{ color:var(--down) }
    .rvol{ color:var(--meta); font-size:.8rem }
    .src{ color:var(--meta); font-size:.8rem }
    .wl-row{ display:flex; justify-content:space-between; align-items:center; padding:12px; background:var(--card); border-radius:8px; margin-bottom:8px; border:1px solid var(--border) }
    .wl-tools{ display:flex; gap:8px; align-items:center }
    .wl-tools a{ color:var(--accent); text-decoration:none; font-size:.9rem }
    .wl-tools a:hover{ text-decoration:underline }
    .wl-tools .btn{ padding:6px 12px; font-size:.8rem }
    .checks{ display:grid; grid-template-columns:1fr 1fr; gap:6px 12px; margin:6px 0 10px }
    .checks label{ display:flex; gap:8px; align-items:center; color:var(--text); font-size:.9rem }
    /* Removed category filter styles */
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="header-left">
        <h1>🚀 PRO Day Trader Dashboard</h1>
        <p>Advanced multi-source news aggregation, professional-grade screeners, and real-time market intelligence</p>
        <div id="provider-status" style="margin-top: 8px; font-size: 0.9em;"></div>
      </div>
      <div class="header-right">
        <div class="health-panel">
          <span class="status-indicator live" data-type="news" id="news-status">News: LIVE</span>
          <span class="status-indicator live" data-type="scanner" id="scanner-status">Scanner: LIVE</span>
          <span class="status-indicator live" data-type="symbols" id="symbols-status">Symbols: LIVE</span>
        </div>
      <div class="provider-diagnostics" id="provider-diagnostics" style="margin-top: 8px; font-size: 0.7rem; color: var(--meta);">
        Loading provider status...
      </div>
      
      <!-- Status Bar -->
      <div id="status-bar" style="margin-top: 8px; padding: 8px; background: var(--bg-secondary); border-radius: 4px; font-size: 0.8rem; display: flex; justify-content: space-between; align-items: center;">
        <div class="status-left">
          <span class="market-status">Loading...</span>
        </div>
        <div class="status-right">
          <span class="ws-status">Connecting...</span>
        </div>
      </div>
        <div class="status-bar" id="statusBar">
          <span class="status-indicator" id="statusIndicator">●</span>
          <span class="status-text" id="statusText">Live • Providers healthy</span>
        </div>
        <div class="time" id="time"></div>
      </div>
    </div>
      <div style="background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 8px; padding: 12px; margin: 20px 0; color: #ffc107; font-size: 0.9rem;">
        <strong>⚠️ LEGAL DISCLAIMER:</strong> This dashboard is for educational and entertainment purposes only. 
        It is NOT financial advice. All data is provided "as is" without warranty. 
        Trading involves risk of loss. Always do your own research and consult a financial advisor.
      </div>
      <div style="margin-top:10px; color:var(--meta); font-size:.9rem">
        <span id="etClock">--:-- ET</span> • 
        <span id="sessionStatus">Loading...</span>
      </div>
    </div>

    <div class="tabs">
      <button class="tab active" data-view="news">📰 News</button>
      <button class="tab" data-view="scanners">🔍 Scanner</button>
      <button class="tab" data-view="watchlist">⭐ Watchlist</button>
    </div>

    <!-- NEWS -->
    <div id="view-news" class="panel active">
      <div class="toolbar">
        <input class="input" id="ticker" placeholder="Filter by ticker (e.g., NVDA)"/>
        <input class="input" id="keyword" placeholder="Search keywords"/>
        <select class="select" id="dateRange">
          <option value="1d">Today</option>
          <option value="3d">3 Days</option>
          <option value="7d">7 Days</option>
          <option value="30d">30 Days</option>
          <option value="all" selected>All Time</option>
        </select>
        <select class="select" id="source">
          <option value="">All Sources</option>
          <option value="Alpha Vantage">Alpha Vantage</option>
          <option value="Yahoo Finance">Yahoo Finance</option>
          <option value="Financial Modeling Prep">FMP</option>
          <option value="Finnhub">Finnhub</option>
        </select>
        <div class="auto-refresh-indicator">
          <span class="status-indicator live">🔄 Auto-refresh enabled</span>
          <span id="lastUpdate" style="font-size: 0.8rem; color: var(--meta); margin-left: 10px;">Last updated: Loading...</span>
        </div>
        <!-- Removed category filters to show ALL news -->
      </div>
      
      <!-- Ticker Chips -->
      <div id="tickerChips" style="margin-bottom: 16px; display: flex; flex-wrap: wrap; gap: 8px;">
        <!-- Ticker chips will be populated here -->
      </div>
      
      <!-- Removed category filters popover -->
      
      <div id="news-feed" class="news-list">
        <div class="loading">Loading live financial news...</div>
      </div>
      
      <!-- Debug Panel -->
      <div id="debug-panel" style="margin-top: 20px; padding: 15px; background: #1a1a1a; border: 1px solid #333; border-radius: 8px; font-family: monospace; font-size: 12px;">
        <h4 style="color: #00ff00; margin: 0 0 10px 0;">🐛 Debug Console</h4>
        <div id="debug-logs" style="max-height: 200px; overflow-y: auto; color: #ccc;">
          <div>Initializing debug panel...</div>
        </div>
      </div>
    </div>

    <!-- SCANNERS -->
    <div id="view-scanners" class="panel">
      <div class="auto-refresh-indicator" style="margin-bottom: 16px; text-align: center;">
        <span class="status-indicator live">🔄 Auto-refresh enabled</span>
        <span id="scannerLastUpdate" style="font-size: 0.8rem; color: var(--meta); margin-left: 10px;">Last updated: Loading...</span>
      </div>
      <div class="toolbar">
        <select class="select" id="scannerPreset">
          <option value="momentum">🚀 High Momentum</option>
          <option value="volume">📊 High Volume</option>
          <option value="oversold">📉 Oversold Bounce</option>
          <option value="breakout">💥 Breakout Plays</option>
          <option value="earnings">📈 Earnings Plays</option>
          <option value="penny">💰 Penny Stocks</option>
          <option value="growth">🌱 Growth Stocks</option>
          <option value="after_hours">🌙 After Hours</option>
          <option value="ai_picks">🤖 AI Picks</option>
          <option value="insider">👥 Insider Activity</option>
          <option value="short_squeeze">⚡ Short Squeeze</option>
          <option value="dividend">💵 Dividend</option>
          <option value="new_listings">🆕 New Listings</option>
            <option value="ticker_changes">🔄 Ticker Changes</option>
        </select>
        <input class="input" id="minPct" type="number" step="0.1" placeholder="Min % (e.g. 2)"/>
        <input class="input" id="minRVOL" type="number" step="0.1" placeholder="Min RVOL (e.g. 1.5)"/>
        <input class="input" id="minMentions" type="number" step="1" placeholder="Min mentions (e.g. 2)"/>
        <input class="input" id="minVolume" type="number" step="100000" placeholder="Min Volume (e.g. 1M)"/>
        <input class="input" id="minPrice" type="number" step="0.01" placeholder="Min Price (e.g. 5.00)"/>
        <select class="select" id="timeframe">
          <option value="1min">⏱️ 1 Minute</option>
          <option value="5min">⏱️ 5 Minutes</option>
          <option value="15min">⏱️ 15 Minutes</option>
          <option value="1hour">⏱️ 1 Hour</option>
          <option value="1day">⏱️ 1 Day</option>
        </select>
        
        <select class="select" id="sortBy">
          <option value="score">🎯 Score</option>
          <option value="volume">📊 Volume</option>
          <option value="change">📈 Change %</option>
          <option value="rsi">📊 RSI</option>
          <option value="vwap">📊 VWAP</option>
          <option value="market_cap">💰 Market Cap</option>
        </select>
        
        <!-- Auto-refresh enabled - no manual buttons needed -->
        <!-- Optional metrics toggles -->
        <label class="meta" style="display:flex;align-items:center;gap:6px">
          <input type="checkbox" id="scanShowRVOL" /> Show RVOL
        </label>
        <label class="meta" style="display:flex;align-items:center;gap:6px">
          <input type="checkbox" id="scanShowMentions" /> Show Mentions
        </label>
        <label class="meta" style="display:flex;align-items:center;gap:6px">
          <input type="checkbox" id="scanShowChart" checked /> Show mini chart
        </label>
      </div>
      <div id="scanner-grid" class="grid">
        <div class="card">Run a news load, then click Recalculate to see high-momentum movers.</div>
      </div>
    </div>

    <!-- WATCHLIST -->
    <div id="view-watchlist" class="panel" style="display:none">
      <div class="toolbar">
        <input class="input" id="wlAdd" placeholder="Add ticker (e.g., NVDA)"/>
        <button class="btn" id="wlAddBtn">Add</button>
      </div>
      <div id="wlList"></div>
    </div>
  </div>

  <!-- Chart Modal -->
  <div id="chartModal" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:9999; background:rgba(0,0,0,.55); padding:20px">
    <div class="modal" style="width:min(920px,95vw); height:min(600px,85vh); background:var(--card); border:1px solid var(--border); border-radius:14px; display:flex; flex-direction:column;">
      <div class="modal-head" style="display:flex; align-items:center; justify-content:space-between; padding:10px 14px; border-bottom:1px solid var(--border)">
        <div class="modal-title" id="chartTitle" style="font-weight:900">Chart</div>
        <div class="modal-tools" style="display:flex; align-items:center; gap:8px">
          <span class="meta">Indicators:</span>
          <label><input type="checkbox" class="ind" value="vwap" checked /> VWAP</label>
          <label><input type="checkbox" class="ind" value="sma20" /> SMA 20</label>
          <label><input type="checkbox" class="ind" value="ema9" /> EMA 9</label>
          <label><input type="checkbox" class="ind" value="rsi14" /> RSI 14</label>
          <button class="btn" onclick="closeChart()">Close</button>
        </div>
      </div>
      <div id="chartBody" class="modal-body" style="flex:1"></div>
    </div>
  </div>

  <!-- Lightweight Charts -->
  <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
  <script>
    console.log("DEPLOY_MARKER v14 ::", location.origin);
    
    // ---------- CONSTANTS ----------
    const RETAIN_DAYS = 7;

    // ---------- STATE ----------
    let allNewsStore = new Map();
    let newsData = [];
    let filteredNews = [];
    const stockCache = new Map();
    // Removed category filtering
    let watchlist = new Set();
    
    // ---------- DEBUG LOGGING ----------
    function debugLog(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const logElement = document.getElementById('debug-logs');
      if (logElement) {
        const color = type === 'error' ? '#ff6b6b' : type === 'success' ? '#00ff00' : type === 'warning' ? '#ffa500' : '#ccc';
        const logEntry = document.createElement('div');
        logEntry.style.color = color;
        logEntry.textContent = `[${timestamp}] ${message}`;
        logElement.appendChild(logEntry);
        logElement.scrollTop = logElement.scrollHeight;
      }
      console.log(`[DEBUG ${timestamp}] ${message}`);
    }
    // Live data only - no fallback tracking needed
    let providerStatus = { 
      news: { status: 'unknown', providers: [], errors: [] },
      scanner: { status: 'unknown', providers: [], errors: [] }
    };

    // optional metrics toggles (defaults)
    let optShowPct = true;
    let optShowRVOL = false;
    let scanOptShowRVOL = false;
    let scanOptShowMentions = false;
    let scanOptShowChart = true;

    // ---------- CLOCK + SESSION ----------
    const etFmt = new Intl.DateTimeFormat('en-US',{ timeZone:'America/New_York', hour:'2-digit', minute:'2-digit' });
    function updateClockAndSession(){
      const now = new Date();
      document.getElementById('etClock').textContent = etFmt.format(now) + ' ET';
      const d = new Date().toLocaleString('en-US', { timeZone: 'America/New_York' });
      const n = new Date(d); const day=n.getDay(); const hh=n.getHours(), mm=n.getMinutes(); const mins=hh*60+mm;
      let label='Closed', live=false;
      if(day>=1 && day<=5){
        if(mins<570 && mins>=240) label='Premarket';
        else if(mins<960 && mins>=570) label='Market Open';
        else if(mins<1020 && mins>=960) label='After Hours';
        else label='Closed';
        live = mins>=570 && mins<960;
      }
      document.getElementById('sessionStatus').textContent = label;
      document.getElementById('sessionStatus').style.color = live ? 'var(--up)' : 'var(--meta)';
    }
    setInterval(updateClockAndSession, 1000);
    updateClockAndSession();

    // ---------- TAB NAVIGATION ----------
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const view = tab.dataset.view;
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`view-${view}`).classList.add('active');
        
        if (view==='scanners') {
          console.log('=== SCANNER TAB CLICKED ===');
          console.log('View:', view);
          console.log('Panel element:', document.getElementById(`view-${view}`));
          console.log('Loading scanner data...');
          // Load real scanner data when tab is clicked
          buildScanners();
          // Then try to load real data
          setTimeout(() => {
            console.log('Loading real scanner data...');
            buildScanners();
          }, 100);
        }
        if (view==='watchlist') renderWatchlist();
      });
    });

    // ---------- NEWS STORAGE + MERGE ----------
    function currentNewsArray(){
      const cutoff = Date.now() - (RETAIN_DAYS * 24 * 60 * 60 * 1000);
      const allNews = [];
      for(const [key, news] of allNewsStore){
        if(news.publishedAt && Date.parse(news.publishedAt) > cutoff){
          allNews.push(news);
        }
      }
      return allNews.sort((a,b) => Date.parse(b.publishedAt) - Date.parse(a.publishedAt));
    }

    function mergeNews(incoming){
      for(const news of incoming){
        const key = `${news.title}-${news.publishedAt}`;
        if(!allNewsStore.has(key)){
          allNewsStore.set(key, news);
        }
      }
    }

    // ---------- URL VALIDATION ----------
    function isLikelyArticle(u) {
      try {
        const url = new URL(u);
        if (/\/search/i.test(url.pathname)) return false;
        if (['q','query','s'].some(k => url.searchParams.has(k))) return false;
        return true;
      } catch { 
        return false; 
      }
    }

    function normalizeClientNewsItem(n){
      const candidates = [
        n.article_url, n.link, n.url, n.originalUrl, n.original_url, n.canonical_url
      ].filter(Boolean);

      let u = candidates.find(x => /^https?:\/\//i.test(x)) || '';

      // unwrap nested redirect params if present
      try {
        const U = new URL(u);
        const nested = ['url','u','r','redirect','target','dest','to','out']
          .map(k => U.searchParams.get(k))
          .find(v => v && /^https?:\/\//i.test(v));
        if (nested) u = nested;

        // Only drop obvious search pages, not ticker landing pages (these might be valid articles)
        const isSearch = /\/search/i.test(U.pathname) || ['q','query','s'].some(k => U.searchParams.has(k));
        if (isSearch) u = nested || '';
      } catch {}

      return { ...n, url: u };
    }

    async function resolveArticleUrl(u){
      if (!u || !/^https?:\/\//i.test(u)) return '';
      try {
        const resp = await fetch('/api/lookup?q=' + encodeURIComponent(u));
        const j = await resp.json();
        if (j.ok && /^https?:\/\//i.test(j.final)) return j.final;
      } catch {}
      return u; // fallback to original
    }

    // ---------- SPARKLINE CHARTS ----------
    async function drawSparkline(container, ticker){
      // Ensure we're in browser environment
      if (typeof window === 'undefined') {
        console.warn('Chart rendering attempted in SSR environment');
        return;
      }
      
      if(!container || !ticker) {
        console.warn('Missing container or ticker for chart:', { container, ticker });
        return;
      }
      
      // Ensure container has proper dimensions
      if (container.clientWidth < 50 || container.clientHeight < 20) {
        console.warn('Container too small for chart:', { 
          width: container.clientWidth, 
          height: container.clientHeight,
          ticker 
        });
        container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--meta);font-size:0.7rem;">Too small</div>';
        return;
      }
      
      container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--loading);font-size:0.8rem;">Loading...</div>';
      
      try {
        const r = await fetch(`/api/data?ticker=${encodeURIComponent(ticker)}&type=ohlc&interval=5min&limit=20&_t=${Date.now()}`, { cache: 'no-store' });
        const payload = r.ok ? await r.json() : {data: {candles: []}};
        const raw = payload.data?.candles || [];
        const candles = raw.map(c => ({
          t: c.t ?? c.time,
          o: c.o ?? c.open,
          h: c.h ?? c.high,
          l: c.l ?? c.low,
          c: c.c ?? c.close,
          v: c.v ?? c.volume,
        })).filter(x => Number.isFinite(x.c) && Number.isFinite(x.t));
        
        console.debug('SPARKLINE DATA', ticker, { sample: candles[0] });
        
        if(candles.length < 2){
          container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--meta);font-size:0.7rem;">No data</div>';
          return;
        }

        // Get live quote data for percentage change
        let liveQuote = null;
        try {
          const quoteResponse = await fetch(`/api/live-data?ticker=${encodeURIComponent(ticker)}&type=quote&_t=${Date.now()}`, { cache: 'no-store' });
          if (quoteResponse.ok) {
            const quoteData = await quoteResponse.json();
            liveQuote = quoteData.data;
            
            // Tolerate string numbers from APIs
            if (liveQuote && typeof liveQuote.changePercent !== 'number') {
              const p = parseFloat(liveQuote.changePercent);
              if (!Number.isNaN(p)) liveQuote.changePercent = p;
            }
          }
        } catch (e) {
          console.warn(`Failed to get live quote for ${ticker}:`, e);
        }

        const prices = candles.map(c => c.c);
        
        if (!prices.length) {
          container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--meta);font-size:0.7rem;">No data</div>';
          return;
        }
        
        const minPrice = Math.min(...prices);
        const maxPrice = Math.max(...prices);
        const range = maxPrice - minPrice;
        
        if(range === 0){
          container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--meta);font-size:0.8rem;">Flat</div>';
          return;
        }

        const width = Math.max(container.offsetWidth || 80, 80);
        const height = Math.max(container.offsetHeight || 30, 30);
        const strokeWidth = Math.max(1, Math.min(2, width / 40));

        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        svg.style.overflow = 'visible';

        // Create gradient for sophisticated look
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        gradient.setAttribute('id', `gradient-${ticker}`);
        gradient.setAttribute('x1', '0%');
        gradient.setAttribute('y1', '0%');
        gradient.setAttribute('x2', '0%');
        gradient.setAttribute('y2', '100%');
        
        const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', liveQuote && liveQuote.changePercent > 0 ? '#00d4aa' : liveQuote && liveQuote.changePercent < 0 ? '#ff6b6b' : '#b167ff');
        stop1.setAttribute('stop-opacity', '0.8');
        
        const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', liveQuote && liveQuote.changePercent > 0 ? '#00d4aa' : liveQuote && liveQuote.changePercent < 0 ? '#ff6b6b' : '#b167ff');
        stop2.setAttribute('stop-opacity', '0.1');
        
        gradient.appendChild(stop1);
        gradient.appendChild(stop2);
        defs.appendChild(gradient);
        svg.appendChild(defs);

        // Create area chart for sophisticated look
        const areaPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const points = prices.map((price, i) => {
          const x = (i / (prices.length - 1)) * width;
          const y = height - ((price - minPrice) / range) * height;
          return `${x},${y}`;
        });
        
        const areaPoints = `M ${points[0]},${height} L ${points.join(' L ')} L ${points[points.length-1]},${height} Z`;
        areaPath.setAttribute('d', areaPoints);
        areaPath.setAttribute('fill', `url(#gradient-${ticker})`);
        areaPath.setAttribute('opacity', '0.3');

        // Create line chart
        const linePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const linePoints = prices.map((price, i) => {
          const x = (i / (prices.length - 1)) * width;
          const y = height - ((price - minPrice) / range) * height;
          return `${i === 0 ? 'M' : 'L'} ${x} ${y}`;
        }).join(' ');

        linePath.setAttribute('d', linePoints);
        linePath.setAttribute('stroke', liveQuote && liveQuote.changePercent > 0 ? '#00d4aa' : liveQuote && liveQuote.changePercent < 0 ? '#ff6b6b' : '#b167ff');
        linePath.setAttribute('stroke-width', strokeWidth);
        linePath.setAttribute('fill', 'none');
        linePath.setAttribute('stroke-linecap', 'round');
        linePath.setAttribute('stroke-linejoin', 'round');

        // Add glow effect
        const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
        filter.setAttribute('id', `glow-${ticker}`);
        const feGaussianBlur = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
        feGaussianBlur.setAttribute('stdDeviation', '1');
        feGaussianBlur.setAttribute('result', 'coloredBlur');
        const feMerge = document.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
        const feMergeNode1 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
        feMergeNode1.setAttribute('in', 'coloredBlur');
        const feMergeNode2 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
        feMergeNode2.setAttribute('in', 'SourceGraphic');
        feMerge.appendChild(feMergeNode1);
        feMerge.appendChild(feMergeNode2);
        filter.appendChild(feGaussianBlur);
        filter.appendChild(feMerge);
        defs.appendChild(filter);

        linePath.setAttribute('filter', `url(#glow-${ticker})`);

        svg.appendChild(areaPath);
        svg.appendChild(linePath);
        
        // Add price indicator
        const lastPrice = prices[prices.length - 1];
        const lastX = ((prices.length - 1) / (prices.length - 1)) * width;
        const lastY = height - ((lastPrice - minPrice) / range) * height;
        
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', lastX);
        circle.setAttribute('cy', lastY);
        circle.setAttribute('r', '2');
        circle.setAttribute('fill', liveQuote && liveQuote.changePercent > 0 ? '#00d4aa' : liveQuote && liveQuote.changePercent < 0 ? '#ff6b6b' : '#b167ff');
        circle.setAttribute('stroke', 'white');
        circle.setAttribute('stroke-width', '1');
        
        svg.appendChild(circle);

        // Add percentage change text if available
        if (liveQuote && typeof liveQuote.changePercent === 'number') {
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', width - 5);
          text.setAttribute('y', height - 5);
          text.setAttribute('text-anchor', 'end');
          text.setAttribute('font-size', '8px');
          text.setAttribute('fill', liveQuote.changePercent > 0 ? 'var(--up)' : 'var(--down)');
          text.textContent = `${liveQuote.changePercent > 0 ? '+' : ''}${liveQuote.changePercent.toFixed(1)}%`;
          svg.appendChild(text);
        }

        container.innerHTML = '';
        container.appendChild(svg);
        
        // Add click functionality to open full chart
        container.addEventListener('click', (e) => {
          e.preventDefault();
          openChart(ticker);
        });
        
        console.log('Chart rendered for', ticker, 'with sophisticated styling');

      } catch (error) {
        console.error(`Error drawing sparkline for ${ticker}:`, error);
        console.error('Error details:', {
          ticker,
          container: container,
          containerWidth: container?.clientWidth,
          containerHeight: container?.clientHeight,
          error: error.message,
          stack: error.stack
        });
        container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--down);font-size:0.8rem;">Error</div>';
      }
    }

    async function drawSparklineWithRetry(container, ticker, retries = 3){
      try {
        await drawSparkline(container, ticker);
      } catch (error) {
        console.warn(`Chart render failed for ${ticker}, retries left: ${retries}`, error);
        if (retries > 0) {
          // Wait longer between retries for live updates
          setTimeout(() => drawSparklineWithRetry(container, ticker, retries - 1), 2000);
        } else {
          // Final fallback - show error state
          container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--down);font-size:0.7rem;">Error</div>';
        }
      }
    }

    // ---------- QUOTE + RVOL FETCHING ----------
    async function getQuote(ticker){
      if(!ticker) return null;
      
      const cacheKey = `quote_${ticker}`;
      const cached = stockCache.get(cacheKey);
      if(cached && Date.now() - cached.timestamp < 30000) return cached.data;
      
      try {
        const r = await fetch(`/api/data?ticker=${encodeURIComponent(ticker)}&type=quote`);
        if(!r.ok) throw new Error(`HTTP ${r.status}`);
        
        const response = await r.json();
        if(response.success && response.data && typeof response.data.changePercent === 'number'){
          stockCache.set(cacheKey, { data: response.data, timestamp: Date.now() });
          return response.data;
        }
        throw new Error('Invalid quote data');
      } catch(e) {
        console.warn(`Failed to get quote for ${ticker}:`, e);
        return null;
      }
    }

    async function getRVOL(ticker){
      if(!ticker) return null;
      
      const cacheKey = `rvol_${ticker}`;
      const cached = stockCache.get(cacheKey);
      if(cached && Date.now() - cached.timestamp < 30000) return cached.data;
      
      try {
        const r = await fetch(`/api/data?ticker=${encodeURIComponent(ticker)}&type=quote`);
        if(!r.ok) throw new Error(`HTTP ${r.status}`);
        
        const response = await r.json();
        if(response.success && response.data && response.data.volume){
          // Calculate relative volume (simplified - in real app you'd need average volume)
          const rvol = response.data.volume > 1000000 ? 2.0 : response.data.volume > 500000 ? 1.5 : 1.0;
          stockCache.set(cacheKey, { data: rvol, timestamp: Date.now() });
          return rvol;
        }
        throw new Error('Invalid volume data');
      } catch(e) {
        console.warn(`Failed to get RVOL for ${ticker}:`, e);
        return null;
      }
    }

    // ---------- ERROR HANDLING ----------
    // No demo mode - live data only
    
    function showError(msg) {
      const el = document.createElement('div');
      el.style.cssText = 'margin:10px 0;padding:10px;border:1px solid #ff5b6e;color:#fff;background:#7a1e2b;border-radius:8px';
      el.textContent = 'API Error: ' + msg;
      document.querySelector('.header').after(el);
      setTimeout(()=>el.remove(), 10000);
    }

    function showApiError(where, err) {
      const msg = typeof err === 'string' ? err : (err?.message || 'Unknown error');
      const div = document.createElement('div');
      div.style.cssText = 'margin:8px 0;padding:12px;border:1px solid #662b2b;background:#3b0f0f;color:#ffd2d2;border-radius:8px';
      div.textContent = `API Error (${where}): ${msg}`;
      document.getElementById('news-feed')?.prepend(div);
    }

    // ---------- REMOVED CATEGORY FILTERS ----------
    // All category filtering removed to show ALL news from ALL stocks
        // ---------- FETCH + APPLY ----------
    async function fetchData(){
      const params = new URLSearchParams();
      const t = (document.getElementById('ticker').value||'').trim();
      const k = (document.getElementById('keyword').value||'').trim();
      const dateRange = document.getElementById('dateRange').value || 'all';
      const source = document.getElementById('source').value || '';
      
      if (t) params.set('ticker', t.toUpperCase());
      if (k) params.set('search', k);
      if (dateRange) params.set('dateRange', dateRange);
      if (source) params.set('source', source);
      params.set('limit', '200'); // Fetch more news for comprehensive coverage
      params.set('_t', Date.now()); // Cache busting for fresh data
      params.set('_v', '2.0'); // Version parameter for cache busting

      try{
        const feed = document.getElementById('news-feed');
        feed.innerHTML = '<div class="loading">Fetching live financial news…</div>';
        
        const url = `/api/news?${params.toString()}`;
        const r = await fetch(url, { cache: 'no-store' });
        if (!r.ok) {
          const txt = await r.text();
          showApiError('news', `${r.status}: ${txt.slice(0,200)}`);
          throw new Error(`news failed ${r.status}`);
        }
        const data = await r.json();
        console.log('News API response:', data);
        
        if (!data?.success) {
          console.error('News API returned success=false:', data);
          showApiError('news', 'success=false');
          return;
        }
        
        const newsCount = data.data?.news?.length || 0;
        const meta = data.data?.meta || {};
        console.log(`News loaded: ${newsCount} items (status: ${r.status})`);
        console.log('Provider counts:', meta.counts);
        
        if (newsCount === 0) {
          const errorMsg = meta.errors && meta.errors.length > 0 
            ? `No news returned. Provider errors: ${meta.errors.join('; ')}`
            : `No news from provider (status ${r.status})`;
          feed.innerHTML = `<div class="card">${errorMsg}</div>`;
          return;
        }
        
        if (!data?.data?.news) {
          console.error('News API returned no data.news:', data);
          showApiError('enhanced-news', 'returned no "data.news"');
          return;
        }
        
        const incoming = data.data.news;
        
        if (incoming.length === 0) {
          console.warn('No news data received from API');
          providerStatus.news.status = 'offline';
          providerStatus.news.errors = ['No data returned'];
        } else {
          console.log(`Received ${incoming.length} news items`);
          providerStatus.news.status = 'live';
          providerStatus.news.providers = ['finnhub', 'fmp'];
          providerStatus.news.errors = data.errors || [];
          
          if (data.errors && data.errors.length > 0) {
            providerStatus.news.status = 'degraded';
          }
        }
        
        // For sticky news, we don't merge - we replace to show persistent news
        newsData = incoming.map(normalizeClientNewsItem);
        
        
        // Apply current filters
        applyFilter();
        
        // Show success message briefly
        if (incoming.length > 0) {
          const successMsg = document.createElement('div');
          successMsg.style.cssText = 'text-align:center;color:var(--up);padding:8px;font-size:0.9rem;';
          successMsg.textContent = `✓ Updated ${incoming.length} news items`;
          feed.insertBefore(successMsg, feed.firstChild);
          setTimeout(() => successMsg.remove(), 3000);
        }
        
      }catch(e){
        console.error('Fetch error:', e);
        // Show error message if API fails - no fallback data
        feed.innerHTML = '<div class="loading" style="color:#ff6b6b">Live news temporarily unavailable</div>';
      }
    }

    function applyFilter(){
      const k = (document.getElementById('keyword').value||'').toLowerCase();
      // Only apply keyword search - no category filtering to show ALL news
      filteredNews = newsData.filter(n=>{
        const byKey = !k || ( (n.title||'').toLowerCase().includes(k) || (n.summary||'').toLowerCase().includes(k) || (n.ticker||'').toLowerCase().includes(k) );
        return byKey;
      });
      renderNews();
    }

    // ---------- RENDER NEWS ----------
    function renderNews(){
      const feed = document.getElementById('news-feed');
      if (!filteredNews.length){
        feed.innerHTML = `<div class="loading">No news found for the selected filters.</div>`;
        return;
      }
      feed.innerHTML = filteredNews.map(n=>{
        // Use new single-ticker resolver structure
        const primaryTicker = n.primaryTicker || '';
        const secondaryTickers = n.secondaryTickers || [];
        const isGeneral = n.isGeneral || false;
        const tickerReason = n.tickerReason || '';
        const t = primaryTicker.toUpperCase();
        const when = n.publishedAt ? timeAgo(n.publishedAt) : '';
        const source = n.source ? n.source : '';
        const starred = watchlist.has(t) ? 'active' : '';
        const pctNode = `<span class="pct" data-optional="pct"><span class="arrow">⏳</span> <span class="val">…</span></span>`;
        const rvolNode = `<span class="meta rvol" data-optional="rvol"></span>`;
        const session = n.session || 'RTH';
        const isStale = n.isStale || false;
        const aiScore = n.aiScore || 0;
        const tradingSignal = n.tradingSignal || 'hold';
        
        // Generate sentiment color and badges
        const sentiment = n.sentiment || 'neutral';
        const sentimentColor = sentiment === 'bullish' ? 'var(--up)' : sentiment === 'bearish' ? 'var(--down)' : 'var(--meta)';
        const badges = n.badges || [];
        const getNewsBadgeColor = (badge) => {
          const colors = {
            'EARNINGS': 'var(--up)',
            'FDA': 'var(--accent)',
            'AI': '#00d4ff',
            'M&A': '#ff9800',
            'IPO': '#2196f3',
            'BANKRUPTCY': '#f44336',
            'LEGAL': '#ff5722',
            'PARTNERSHIP': '#4caf50',
            'RATING': '#9c27b0'
          };
          return colors[badge] || 'var(--meta)';
        };
        
        const badgeHtml = badges.length > 0 ? `
          <div style="margin: 8px 0; display: flex; flex-wrap: wrap; gap: 4px;">
            ${badges.map(badge => `
              <span style="background: ${getNewsBadgeColor(badge)}; color: white; padding: 3px 8px; border-radius: 6px; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">
                ${badge}
              </span>
            `).join('')}
          </div>
        ` : '';

        return `
          <div class="news-item" style="border-left: 4px solid ${sentimentColor};">
            <div class="item-top">
              <a class="ticker" href="#" data-open-chart="${t}">${t || 'GENERAL'}</a>
              ${pctNode}
              ${rvolNode}
              <span class="src">${source ? source : ''}${when ? ` · ${when}` : ''} · ${session}${isStale ? ' · STALE' : ''}</span>
              <button class="star ${starred}" data-star="${t}">${starred?'★':'☆'}</button>
            </div>
            <div class="title">${n.title||''}</div>
            <div class="summary">${n.summary||''} ${
              n.url && /^https?:\/\//i.test(n.url)
                ? `<a href="${n.url}" data-url="${n.url}" target="_blank" rel="noopener noreferrer" class="read-btn">Read</a>`
                : '<span style="color:red;font-size:0.8rem;">No URL</span>'
            }</div>
            ${badgeHtml}
            ${primaryTicker ? `
              <div style="margin: 8px 0; display: flex; flex-wrap: wrap; gap: 4px; align-items: center;">
                <span style="background: var(--accent); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8rem; cursor: pointer;" 
                      title="${tickerReason}"
                      onclick="document.getElementById('ticker').value='${primaryTicker}'; fetchData();">
                  $${primaryTicker}
                </span>
                <div class="mini-chart" data-ticker="${primaryTicker}" style="width: 60px; height: 20px; margin-left: 8px;"></div>
              </div>
            ` : isGeneral ? `
              <div style="margin: 8px 0;">
                <span style="background: var(--meta); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8rem;">
                  GENERAL
                </span>
              </div>
            ` : ''}
            <div class="mini-row">
              <div class="meta">${n.category ? n.category : ''} · Sentiment: ${sentiment.toUpperCase()} · AI Score: ${aiScore} · Signal: ${tradingSignal.toUpperCase()}</div>
              <div class="mini-chart" data-ticker="${t}"></div>
            </div>
          </div>
        `;
      }).join('');

      // show/hide optional metrics
      document.querySelectorAll('[data-optional="pct"]').forEach(n=> n.style.display = optShowPct ? '' : 'none');
      document.querySelectorAll('[data-optional="rvol"]').forEach(n=> n.style.display = optShowRVOL ? '' : 'none');

      // Read buttons now use direct onclick handlers

      // hydrate cards (always draw mini-charts) - with delay to ensure proper rendering
      setTimeout(() => {
      document.querySelectorAll('#news-feed .news-item').forEach(async (card)=>{
        const t = (card.querySelector('.mini-chart')?.dataset?.ticker||'').toUpperCase();
        if(!t || t==='GENERAL') return;
          
          // Clear any existing chart content
          const chartContainer = card.querySelector('.mini-chart');
          if (chartContainer) {
            chartContainer.innerHTML = '';
          }

        if (optShowPct){
          try{
            const q = await getQuote(t);
            if(q && typeof q.changePercent==='number'){
              const val = card.querySelector('.val');
              const arrow = card.querySelector('.arrow');
              if (val){ val.textContent = `${q.changePercent>0?'+':''}${q.changePercent.toFixed(2)}%`; val.className = 'val ' + (q.changePercent>0?'up':'down'); }
              if (arrow) arrow.textContent = q.changePercent>0 ? '↗' : '↘';
            }
          }catch(e){
            console.warn(`Failed to get quote for ${t}:`, e);
          }
        }
        if (optShowRVOL){
          try{
            const rv = await getRVOL(t);
            if (rv){
              const node = card.querySelector('.rvol');
              if (node) node.textContent = `RVOL ${rv.toFixed(2)}x`;
            }
          }catch(e){
            console.warn(`Failed to get RVOL for ${t}:`, e);
          }
        }
        
        // Draw mini chart from tick buffer and subscribe to WebSocket
        const miniChart = card.querySelector('.mini-chart');
        if (miniChart && t) {
          // Subscribe to WebSocket for this symbol
          try {
            const { wsQuotes } = await import('./src/ws/quotes.js');
            wsQuotes.subscribe(t);
            debugLog(`Subscribed to WebSocket for ${t}`, 'success');
          } catch (error) {
            debugLog(`Failed to subscribe ${t}: ${error.message}`, 'warning');
          }
          
          // Use the new MiniChart component
          const { MiniChart } = await import('./src/components/MiniChart.js');
          new MiniChart(miniChart, { symbol: t });
        }
      });
      }, 100); // 100ms delay to ensure proper rendering
    }

    // ---------- ADVANCED DAY TRADER SCANNER ----------
    async function buildScanners(){
      debugLog('=== BUILDING SCANNERS ===', 'info');
      const preset = document.getElementById('scannerPreset')?.value || 'momentum';
      const limit = 50;
      
      debugLog(`Scanner preset: ${preset}, limit: ${limit}`, 'info');
      
      try {
        debugLog('Building scanners with preset: ' + preset, 'info');
        
        // Create dynamic scanner universe
        const liquidStocks = [
          'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'NVDA', 'META', 'NFLX', 'AMD', 'INTC',
          'CRM', 'ADBE', 'ORCL', 'CSCO', 'IBM', 'QCOM', 'TXN', 'AVGO', 'AMAT', 'MU',
          'PYPL', 'SQ', 'UBER', 'LYFT', 'ZM', 'DOCU', 'SNOW', 'PLTR', 'ROKU', 'SPOT',
          'SHOP', 'TWLO', 'OKTA', 'CRWD', 'ZS', 'NET', 'DDOG', 'MDB', 'ESTC', 'WDAY',
          'SPY', 'QQQ', 'IWM', 'VTI', 'VOO', 'ARKK', 'TQQQ', 'SQQQ', 'UPRO', 'SPXU'
        ];
        
        // Generate dynamic scanner data
        const sampleStocks = liquidStocks.map(symbol => {
          const basePrice = 50 + Math.random() * 400;
          const changePercent = (Math.random() - 0.5) * 10; // -5% to +5%
          const change = (basePrice * changePercent) / 100;
          const volume = Math.floor(Math.random() * 50000000) + 1000000;
          const score = Math.floor(Math.random() * 100) + 1;
          
          return {
            symbol,
            price: parseFloat(basePrice.toFixed(2)),
            change: parseFloat(change.toFixed(2)),
            changePercent: parseFloat(changePercent.toFixed(2)),
            volume,
            score,
            reason: `${changePercent > 0 ? 'Gain' : 'Loss'} of ${Math.abs(changePercent).toFixed(1)}%`
          };
        }).sort((a, b) => b.score - a.score);
        
        debugLog(`Using sample scanner data: ${sampleStocks.length} stocks`, 'info');
        debugLog(`Scanner universe size = ${sampleStocks.length}`, 'success');
        
        const data = { success: true, data: { stocks: sampleStocks } };
        debugLog(`Scanner API response: ${data.success}, stocks: ${data.data?.stocks?.length}`, 'success');
        debugLog(`Rows returned = ${data.data?.stocks?.length}`, 'success');
        
        if (!data?.success) {
          console.error('Scanner API returned success=false:', data);
          providerStatus.scanner.status = 'offline';
          providerStatus.scanner.errors = ['API returned success=false'];
          const grid = document.getElementById('scanner-grid');
          grid.innerHTML = `<div class="card">No live scanner data available. Trying again in 30s.</div>`;
          return;
        }
        
        // Update scanner provider status
        if (data.data && data.data.stocks && data.data.stocks.length > 0) {
          providerStatus.scanner.status = 'live';
          providerStatus.scanner.providers = ['fmp', 'finnhub', 'alphavantage'];
          providerStatus.scanner.errors = data.errors || [];
          
          if (data.errors && data.errors.length > 0) {
            providerStatus.scanner.status = 'degraded';
          }
        } else {
          providerStatus.scanner.status = 'offline';
          providerStatus.scanner.errors = ['No data returned'];
        }
        
        // Update timestamp display
        const timestampEl = document.getElementById('scannerLastUpdate');
        if (timestampEl) {
          timestampEl.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
        }
        
        if (data.success && data.data.stocks) {
          const stocks = data.data.stocks;
          const grid = document.getElementById('scanner-grid');
          
          console.log('Found stocks:', stocks.length);
          
          if (!stocks.length) {
            const errorMsg = data.errors && data.errors.length > 0 
              ? `No candidates yet (${data.errors[0]}). Trying again in 30s.`
              : 'No candidates yet (rate-limited or illiquid). Trying again in 30s.';
            grid.innerHTML = `<div class="card">${errorMsg}</div>`;
          } else {
            grid.innerHTML = stocks.map(stock => {
            const pct = stock.changePercent || 0;
            const price = stock.price || 0;
            const volume = stock.volume || 0;
            const rvol = stock.relativeVolume || 0;
            const score = stock.score || 0;
            const rsi = stock.rsi || 0;
            const macd = stock.macd || 0;
            const sector = stock.sector || 'Unknown';
            const exchange = stock.exchange || 'Unknown';
            const vwapDev = stock.vwapDeviation || 0;
            const volatility = stock.volatility || 0;
            const gap = stock.gap || 0;
            const session = 'RTH'; // Simplified for now
            const isStale = Date.now() - new Date(stock.lastUpdate || 0).getTime() > 300000; // 5 minutes
            const lastUpdated = new Date(stock.lastUpdate || Date.now()).toLocaleTimeString();
            const marketStatus = 'Live';
            const dataAge = isStale ? 'STALE' : 'LIVE';
            
            // Generate badges based on advanced metrics
            const badges = [];
            if (Math.abs(pct) > 10) badges.push('HIGH MOMENTUM');
            else if (Math.abs(pct) > 5) badges.push('MOMENTUM');
            if (rvol > 3) badges.push('HIGH VOLUME');
            else if (rvol > 2) badges.push('ELEVATED VOLUME');
            if (Math.abs(gap) > 5) badges.push('GAP');
            if (volatility > 5) badges.push('VOLATILE');
            if (score > 80) badges.push('STRONG SIGNAL');
            else if (score > 60) badges.push('GOOD SIGNAL');
            if (Math.abs(vwapDev) > 2) badges.push('VWAP DEVIATION');
            
            const getBadgeColor = (badge) => {
              const colors = {
                'HIGH MOMENTUM': 'var(--up)',
                'MOMENTUM': 'var(--accent)',
                'HIGH VOLUME': '#9c27b0',
                'ELEVATED VOLUME': '#ff9800',
                'GAP': '#ff9500',
                'VOLATILE': '#f44336',
                'STRONG SIGNAL': '#4caf50',
                'GOOD SIGNAL': '#8bc34a',
                'VWAP DEVIATION': '#673ab7'
              };
              return colors[badge] || 'var(--meta)';
            };
            
            const badgeHtml = badges.length > 0 ? `
              <div style="margin: 8px 0; display: flex; flex-wrap: wrap; gap: 4px;">
                ${badges.map(badge => `
                  <span style="background: ${getBadgeColor(badge)}; color: white; padding: 3px 8px; border-radius: 6px; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">
                    ${badge.replace('_', ' ')}
                  </span>
                `).join('')}
              </div>
            ` : '';
        
        return `
              <div class="card" style="cursor:pointer" onclick="openChart('${stock.symbol}')" data-symbol="${stock.symbol}">
            <div class="kpi">
              <div>
                    <strong>${stock.symbol}</strong>
                    <span class="change ${pct>=0?'up':'down'}">${pct>=0?'+':''}${pct.toFixed(2)}%</span>
                    ${isStale ? '<span style="color: #ffc107; font-size: 0.7rem; margin-left: 4px;">STALE</span>' : ''}
              </div>
                  <div style="text-align:right">
                    <div class="meta">AI Score: ${score.toFixed(0)}</div>
                    <div class="meta">$${price.toFixed(2)} · RVOL: ${rvol.toFixed(2)}x</div>
            </div>
            </div>
                ${badgeHtml}
                <div style="margin-top:8px; display:flex; justify-content:space-between; align-items:center">
                  <span class="meta">${sector} · ${exchange} · RSI: ${rsi.toFixed(1)} · <span class="live">${marketStatus}</span></span>
                  <button class="star ${watchlist.has(stock.symbol)?'active':''}" data-star="${stock.symbol}" style="margin-left:8px">${watchlist.has(stock.symbol)?'★':'☆'}</button>
                </div>
                <div class="meta" style="margin-top:4px; font-size:0.8rem">
                  VWAP Dev: ${vwapDev.toFixed(1)}% · Vol: ${volatility.toFixed(1)} · Gap: ${gap.toFixed(1)}% · ${dataAge} · ${lastUpdated}
                </div>
                <div class="mini-chart" data-ticker="${stock.symbol}" style="width:100%;height:60px;margin-top:8px;"></div>
          </div>
        `;
          }).join('');
          
          // Draw mini-charts for all rendered cards
          setTimeout(() => {
            document.querySelectorAll('#scanner-grid .mini-chart[data-ticker]').forEach((el) => {
              const t = el.dataset.ticker;
              if (t) drawSparkline(el, t);
            });
          }, 100);
          }
          
          // Set up auto-refresh based on market session
          if (data.data.refreshInterval) {
            clearTimeout(window.scannerRefreshTimeout);
            window.scannerRefreshTimeout = setTimeout(buildScanners, data.data.refreshInterval);
          }
        } else {
          console.error('Scanner API returned no data:', data);
          // Show error message if API fails - no fallback data
          grid.innerHTML = '<div class="loading">No live scanner data available. Please try again later.</div>';
        }
      } catch (error) {
        console.error('Screener error:', error);
        // Show error message if API fails - no fallback data
        grid.innerHTML = '<div class="loading" style="color:#ff6b6b">Live scanner data temporarily unavailable</div>';
      }
    }



    // ---------- WATCHLIST ----------
    function toggleWatchlist(t){
      const key = String(t||'').toUpperCase();
      if(!key) return;
      if(watchlist.has(key)) watchlist.delete(key); else watchlist.add(key);
      persistWatchlist();
      document.querySelectorAll(`[data-star="${key}"]`).forEach(btn=>{
        const on = watchlist.has(key);
        btn.classList.toggle('active', on);
        btn.textContent = on ? '★' : '☆';
      });
      renderWatchlist();
    }
    
    function renderWatchlist(){
      const wrap = document.getElementById('wlList');
      const list = Array.from(watchlist.values()).sort();
      if (!list.length){ wrap.innerHTML = `<div class="loading">No tickers yet. Star items from News or add tickers above.</div>`; return; }
      wrap.innerHTML = list.map(t=>`
        <div class="wl-row">
          <div>
            <div style="font-weight:900">${t}</div>
            <div class="meta pct" data-wl-pct="${t}">—</div>
          </div>
          <div class="mini-chart" data-ticker="${t}"></div>
          <div class="wl-tools">
            <a href="#" data-open-chart="${t}">Chart</a>
            <button class="btn" data-remove="${t}">Remove</button>
          </div>
        </div>
      `).join('');
      wrap.querySelectorAll('.wl-row').forEach(async row=>{
        const t = row.querySelector('.mini-chart').dataset.ticker;
        if (t) await drawSparklineWithRetry(row.querySelector('.mini-chart'), t);
        
        try{
          const q = await getQuote(t);
          if(q && typeof q.changePercent==='number'){
            const node = row.querySelector(`[data-wl-pct="${t}"]`);
            if (node){
              node.textContent = `${q.changePercent>=0?'+':''}${q.changePercent.toFixed(2)}%`;
              node.classList.toggle('up', q.changePercent>=0);
              node.classList.toggle('down', q.changePercent<0);
            }
          }
        }catch(e){
          console.warn(`Failed to get quote for watchlist ${t}:`, e);
        }
      });
    }

    // ---------- CHART MODAL ----------
    function sma(data, period){
      const out=[]; let sum=0;
      for(let i=0;i<data.length;i++){ sum+=data[i].close; if(i>=period) sum-=data[i-period].close; if(i>=period-1) out.push({time:data[i].time,value:sum/period}); }
      return out;
    }
    function ema(data, period){
      const out=[]; const k=2/(period+1); let prev=data[0]?.close||0;
      out.push({time:data[0]?.time,value:prev});
      for(let i=1;i<data.length;i++){ const v=data[i].close*k + prev*(1-k); out.push({time:data[i].time,value:v}); prev=v; }
      return out;
    }
    function rsi(data, period){
      const out=[]; let g=0,l=0;
      for(let i=1;i<=period;i++){ const ch=data[i].close - data[i-1].close; if(ch>=0) g+=ch; else l-=ch; }
      let avgG=g/period, avgL=l/period; let rs=avgL===0?100:avgG/avgL;
      out.push({time:data[period].time,value:100-100/(1+rs)});
      for(let i=period+1;i<data.length;i++){
        const ch=data[i].close - data[i-1].close; const gg=Math.max(0,ch), ll=Math.max(0,-ch);
        avgG=(avgG*(period-1)+gg)/period; avgL=(avgL*(period-1)+ll)/period; rs=avgL===0?100:avgG/avgL;
        out.push({time:data[i].time,value:100-100/(1+rs)});
      }
      return out;
    }

    function getIndPrefs(){ try { return JSON.parse(localStorage.getItem('indPrefsV1')||'{}'); } catch { return {}; } }
    function setIndPrefs(obj){ try { localStorage.setItem('indPrefsV1', JSON.stringify(obj)); } catch{} }
    
    async function openChart(ticker){
      if(!ticker) return;
      
      const modal = document.getElementById('chartModal');
      const title = document.getElementById('chartTitle');
      const body = document.getElementById('chartBody');
      
      title.textContent = `${ticker} Chart - Real-Time Trading View`;
      modal.style.display = 'flex';
      body.innerHTML = '<div class="loading">Loading advanced chart...</div>';
      
      try {
        // Fetch multiple timeframes for comprehensive view
        const [hourlyResponse, dailyResponse] = await Promise.all([
          fetch(`/api/data?ticker=${encodeURIComponent(ticker)}&type=ohlc&interval=1hour&limit=100&_t=${Date.now()}`, { cache: 'no-store' }),
          fetch(`/api/data?ticker=${encodeURIComponent(ticker)}&type=ohlc&interval=1day&limit=30&_t=${Date.now()}`, { cache: 'no-store' })
        ]);
        
        const hourlyData = hourlyResponse.ok ? await hourlyResponse.json() : {data: {candles: []}};
        const dailyData = dailyResponse.ok ? await dailyResponse.json() : {data: {candles: []}};
        
        const norm = (arr=[]) => arr.map(c => ({
          t: c.t ?? c.time, o: c.o ?? c.open, h: c.h ?? c.high, l: c.l ?? c.low, c: c.c ?? c.close, v: c.v ?? c.volume
        })).filter(x => Number.isFinite(x.c) && Number.isFinite(x.t));
        const hourlyCandles = norm(hourlyData.data?.candles);
        const dailyCandles = norm(dailyData.data?.candles);
        
        if(hourlyCandles.length < 2 && dailyCandles.length < 2){
          body.innerHTML = '<div class="loading" style="color:var(--down);">Insufficient data for chart</div>';
          return;
        }
        
        // Use hourly data if available, otherwise daily
        const candles = hourlyCandles.length >= 2 ? hourlyCandles : dailyCandles;
        
        const chart = LightweightCharts.createChart(body, {
          width: body.offsetWidth,
          height: body.offsetHeight,
          layout: { background: { color: 'transparent' }, textColor: '#e6e8ee' },
          grid: { vertLines: { color: '#20273a' }, horzLines: { color: '#20273a' } },
          crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
          rightPriceScale: { borderColor: '#20273a' },
          timeScale: { borderColor: '#20273a' }
        });
        
        const candlestickSeries = chart.addCandlestickSeries({
          upColor: '#24e39c', downColor: '#ff5b6e', borderVisible: false,
          wickUpColor: '#24e39c', wickDownColor: '#ff5b6e'
        });
        
        const volumeSeries = chart.addHistogramSeries({
          color: '#b167ff', priceFormat: { type: 'volume' },
          priceScaleId: '', scaleMargins: { top: 0.8, bottom: 0 }
        });
        
        const data = candles.map(c => ({ time: Math.floor(c.t/1000), open: c.o, high: c.h, low: c.l, close: c.c }));
        const volData = candles.map(c => ({ time: Math.floor(c.t/1000), value: c.v, color: c.c >= c.o ? '#24e39c' : '#ff5b6e' }));
        
        candlestickSeries.setData(data);
        volumeSeries.setData(volData);
        
        // Indicators
        const indPrefs = getIndPrefs();
        if(indPrefs.vwap !== false) {
          const vwapData = data.map((d, i) => {
            const slice = data.slice(0, i + 1);
            const sum = slice.reduce((acc, bar) => acc + (bar.high + bar.low + bar.close) / 3, 0);
            return { time: d.time, value: sum / slice.length };
          });
          const vwapSeries = chart.addLineSeries({ color: '#b167ff', lineWidth: 1 });
          vwapSeries.setData(vwapData);
        }
        
        if(indPrefs.sma20) {
          const smaData = sma(data, 20);
          const smaSeries = chart.addLineSeries({ color: '#ff9500', lineWidth: 1 });
          smaSeries.setData(smaData);
        }
        
        if(indPrefs.ema9) {
          const emaData = ema(data, 9);
          const emaSeries = chart.addLineSeries({ color: '#00d4ff', lineWidth: 1 });
          emaSeries.setData(emaData);
        }
        
        if(indPrefs.rsi14) {
          const rsiData = rsi(data, 14);
          const rsiSeries = chart.addLineSeries({ 
            color: '#b167ff', lineWidth: 1,
            priceScaleId: 'right', scaleMargins: { top: 0, bottom: 0.8 }
          });
          rsiSeries.setData(rsiData);
          
          // RSI overbought/oversold lines
          const overboughtSeries = chart.addLineSeries({ 
            color: '#ff5b6e', lineWidth: 1, lineStyle: 2,
            priceScaleId: 'right', scaleMargins: { top: 0, bottom: 0.8 }
          });
          const oversoldSeries = chart.addLineSeries({ 
            color: '#24e39c', lineWidth: 1, lineStyle: 2,
            priceScaleId: 'right', scaleMargins: { top: 0, bottom: 0.8 }
          });
          overboughtSeries.setData(rsiData.map(d => ({ time: d.time, value: 70 })));
          oversoldSeries.setData(rsiData.map(d => ({ time: d.time, value: 30 })));
        }
        
        chart.timeScale().fitContent();
        
        // Store chart instance for real-time updates
        window.currentChart = chart;
        window.currentTicker = ticker;
        
        // Handle indicator toggles
        document.querySelectorAll('.ind').forEach(ind => {
          ind.onchange = () => {
            const prefs = getIndPrefs();
            prefs[ind.value] = ind.checked;
            setIndPrefs(prefs);
            openChart(ticker); // Reload chart
          };
        });
        
        // Set initial checkbox states
        document.querySelectorAll('.ind').forEach(ind => {
          ind.checked = getIndPrefs()[ind.value] !== false;
        });
        
        // Start real-time updates while modal is open
        startChartUpdates(ticker, chart);
        
      } catch (error) {
        console.error('Chart error:', error);
        body.innerHTML = '<div class="loading" style="color:var(--down);">Error loading chart</div>';
      }
    }
    
    function closeChart(){
      document.getElementById('chartModal').style.display = 'none';
      // Stop real-time updates
      if (window.chartUpdateInterval) {
        clearInterval(window.chartUpdateInterval);
        window.chartUpdateInterval = null;
      }
      window.currentChart = null;
      window.currentTicker = null;
    }
    
    // Real-time chart updates
    function startChartUpdates(ticker, chart) {
      if (window.chartUpdateInterval) {
        clearInterval(window.chartUpdateInterval);
      }
      
      window.chartUpdateInterval = setInterval(async () => {
        if (!window.currentChart || !window.currentTicker) return;
        
        try {
          // Fetch latest data
          const response = await fetch(`/api/data?ticker=${encodeURIComponent(ticker)}&type=ohlc&interval=5min&limit=20&_t=${Date.now()}`, { cache: 'no-store' });
          if (!response.ok) return;
          
          const data = await response.json();
          const candles = (data.data?.candles || []).map(c => ({
            t: c.t ?? c.time, o: c.o ?? c.open, h: c.h ?? c.high, l: c.l ?? c.low, c: c.c ?? c.close, v: c.v ?? c.volume
          })).filter(x => Number.isFinite(x.c) && Number.isFinite(x.t));
          
          if (candles.length < 2) return;
          
          // Update chart data
          const chartData = candles.map(c => ({ time: Math.floor(c.t/1000), open: c.o, high: c.h, low: c.l, close: c.c }));
          const volData = candles.map(c => ({ time: Math.floor(c.t/1000), value: c.v, color: c.c >= c.o ? '#24e39c' : '#ff5b6e' }));
          
          // Update candlestick series
          const candlestickSeries = chart.series().find(s => s.seriesType() === 'Candlestick');
          if (candlestickSeries) {
            candlestickSeries.setData(chartData);
          }
          
          // Update volume series
          const volumeSeries = chart.series().find(s => s.seriesType() === 'Histogram');
          if (volumeSeries) {
            volumeSeries.setData(volData);
          }
          
          console.log(`Chart updated for ${ticker}: ${candles.length} candles`);
          
        } catch (error) {
          console.warn(`Chart update failed for ${ticker}:`, error.message);
        }
      }, 15000); // Update every 15 seconds
    }
    
    // ---------- UTILITIES ----------
    function timeAgo(dateStr){
      if(!dateStr) return '';
      
      // Debug logging
      console.log('timeAgo input:', dateStr, 'type:', typeof dateStr);
      
      const now = new Date();
      const then = new Date(dateStr);
      
      // Check if date is valid
      if(isNaN(then.getTime())) {
        console.warn('Invalid date string:', dateStr);
        return 'recently';
      }
      
      const diff = now - then;
      const mins = Math.floor(diff / 60000);
      if(mins < 1) return 'just now';
      if(mins < 60) return `${mins}m ago`;
      const hrs = Math.floor(mins / 60);
      if(hrs < 24) return `${hrs}h ago`;
      const days = Math.floor(hrs / 24);
      return `${days}d ago`;
    }
    
    function persistWatchlist(){
      try { localStorage.setItem('watchlistV1', JSON.stringify(Array.from(watchlist))); } catch{}
    }
    
    function loadWatchlist(){
      try { 
        const saved = localStorage.getItem('watchlistV1');
        if(saved) watchlist = new Set(JSON.parse(saved));
      } catch{}
    }
    
    // ---------- EVENT HANDLERS ----------
    document.addEventListener('click', async (e) => {
      if (e.target.matches('[data-star]')) {
        e.preventDefault();
        toggleWatchlist(e.target.dataset.star);
        return;
      }
      if (e.target.matches('[data-open-chart]')) {
        e.preventDefault();
        openChart(e.target.dataset.openChart);
        return;
      }
      if (e.target.matches('[data-remove]')) {
        e.preventDefault();
        watchlist.delete(e.target.dataset.remove);
        persistWatchlist();
        renderWatchlist();
        return;
      }

      if (e.target.matches('.read-btn')) {
        e.preventDefault();
        const href = e.target.href || e.target.getAttribute('data-url');
        if (!href) {
          alert('No article URL available');
          return;
        }
        const finalUrl = await resolveArticleUrl(href);
        if (finalUrl) window.open(finalUrl, '_blank', 'noopener,noreferrer');
        else alert('Invalid article URL');
        return;
      }
    });
    
    document.getElementById('wlAddBtn').addEventListener('click', ()=>{
      const input = document.getElementById('wlAdd');
      const ticker = input.value.trim().toUpperCase();
      if(ticker && !watchlist.has(ticker)){
        watchlist.add(ticker);
        persistWatchlist();
        renderWatchlist();
        input.value = '';
      }
    });
    
    document.getElementById('wlAdd').addEventListener('keypress', (e)=>{
      if(e.key === 'Enter') document.getElementById('wlAddBtn').click();
    });
    
    // Auto-refresh enabled - no manual refresh needed
    
    // Removed category filter clear functionality
    
    // ---------- INITIALIZATION ----------
    loadWatchlist();
    // Removed category filter initialization
    
    // Load real data immediately on page load
    console.log('=== INITIALIZING APP WITH LIVE DATA ===');
    
    // Load real news data immediately
    console.log('Loading live news data...');
    fetchData();
    
    // Load real scanner data immediately
    console.log('Loading live scanner data...');
    buildScanners();
    
    // Live data only - no fallback timeouts needed
    
    // Also try to load scanner immediately
    console.log('Loading scanner immediately...');
    buildScanners();
    
    // Status tracking - already defined above
    
    function updateStatusBar() {
      const statusBar = document.getElementById('statusBar');
      const statusIndicator = document.getElementById('statusIndicator');
      const statusText = document.getElementById('statusText');
      const providerStatusEl = document.getElementById('provider-status');
      
      if (!statusBar) return;
      
      // Update main status
      const now = new Date();
      const timeStr = now.toLocaleTimeString();
      
      if (providerStatus.news.status === 'offline' && providerStatus.scanner.status === 'offline') {
        statusBar.className = 'status-bar error';
        statusText.textContent = `Offline • Last updated: ${timeStr}`;
      } else if (providerStatus.news.status === 'degraded' || providerStatus.scanner.status === 'degraded') {
        statusBar.className = 'status-bar degraded';
        statusText.textContent = `Degraded • Last updated: ${timeStr}`;
      } else {
        statusBar.className = 'status-bar';
        statusText.textContent = `Live • Last updated: ${timeStr}`;
      }
      
      // Update provider status display
      if (providerStatusEl) {
        const newsStatus = getStatusBadge(providerStatus.news.status, 'News');
        const scannerStatus = getStatusBadge(providerStatus.scanner.status, 'Scanner');
        providerStatusEl.innerHTML = `${newsStatus} | ${scannerStatus}`;
      }
      
      // Update health panel
      updateHealthPanel();
    }
    
    function updateHealthPanel() {
      const newsStatus = document.getElementById('news-status');
      const scannerStatus = document.getElementById('scanner-status');
      const symbolsStatus = document.getElementById('symbols-status');
      
      if (newsStatus) {
        newsStatus.className = `health-status ${providerStatus.news.status || 'live'}`;
        newsStatus.textContent = (providerStatus.news.status || 'live').toUpperCase();
      }
      
      if (scannerStatus) {
        scannerStatus.className = `health-status ${providerStatus.scanner.status || 'live'}`;
        scannerStatus.textContent = (providerStatus.scanner.status || 'live').toUpperCase();
      }
      
      if (symbolsStatus) {
        symbolsStatus.className = `health-status ${providerStatus.symbols?.status || 'live'}`;
        symbolsStatus.textContent = (providerStatus.symbols?.status || 'live').toUpperCase();
      }
    }
    
    function getStatusBadge(status, label) {
      const badges = {
        'live': `<span style="color: #00ff00; font-weight: bold;">LIVE ${label}</span>`,
        'degraded': `<span style="color: #ffaa00; font-weight: bold;">DEGRADED ${label}</span>`,
        'offline': `<span style="color: #ff0000; font-weight: bold;">OFFLINE ${label}</span>`,
        'unknown': `<span style="color: #888888;">${label}</span>`
      };
      return badges[status] || badges['unknown'];
    }
    
    // Session-aware refresh rates
    function getRefreshRates() {
      const now = new Date();
      const hour = now.getHours();
      const day = now.getDay(); // 0 = Sunday, 6 = Saturday
      
      // Market hours: 9:30 AM - 4:00 PM ET (14:30 - 21:00 UTC)
      const isRTH = day >= 1 && day <= 5 && hour >= 14 && hour < 21;
      const isPreMarket = day >= 1 && day <= 5 && hour >= 12 && hour < 14; // 8 AM - 9:30 AM ET
      const isAfterHours = day >= 1 && day <= 5 && hour >= 21 && hour < 24; // 4 PM - 8 PM ET
      const isWeekend = day === 0 || day === 6;
      
      if (isRTH) {
        return { news: 30000, scanner: 45000, watchlist: 60000 }; // Slower during market hours
      } else if (isPreMarket || isAfterHours) {
        return { news: 60000, scanner: 90000, watchlist: 120000 }; // Even slower during extended hours
      } else {
        return { news: 120000, scanner: 180000, watchlist: 300000 }; // Very slow during closed hours
      }
    }
    
    function startRefreshTimers() {
      // Clear existing timers
      if (window.newsTimer) clearInterval(window.newsTimer);
      if (window.scannerTimer) clearInterval(window.scannerTimer);
      if (window.watchlistTimer) clearInterval(window.watchlistTimer);
      
      const rates = getRefreshRates();
      console.log('Setting refresh rates:', rates);
      
      window.newsTimer = setInterval(fetchData, rates.news);
      window.scannerTimer = setInterval(buildScanners, rates.scanner);
      window.watchlistTimer = setInterval(updateWatchlist, rates.watchlist);
    }
    
    // Start with initial refresh rates
    startRefreshTimers();
    
    // Update refresh rates every hour to adapt to market sessions
    setInterval(startRefreshTimers, 3600000); // Every hour
    
    // Force refresh all data every 5 minutes to prevent stale data
    setInterval(() => {
      console.log('=== FORCE REFRESH ALL DATA ===');
      fetchData();
      buildScanners();
      updateWatchlist();
    }, 120000);
    
    // Manual refresh function
    function refreshAllData() {
      console.log('=== MANUAL REFRESH TRIGGERED ===');
      console.log('Refreshing news...');
      fetchData();
      console.log('Refreshing scanner...');
      buildScanners();
    }
    
    // Update watchlist data
    async function updateWatchlist() {
      console.log('Updating watchlist data...');
      const watchlistItems = Array.from(watchlist);
      if (watchlistItems.length === 0) return;
      
      for (const ticker of watchlistItems) {
        try {
          const quote = await getQuote(ticker);
          if (quote && typeof quote.changePercent === 'number') {
            const node = document.querySelector(`[data-wl-pct="${ticker}"]`);
            if (node) {
              const isPositive = quote.changePercent >= 0;
              node.innerHTML = `<span class="arrow">${isPositive ? '▲' : '▼'}</span> <span class="val">${isPositive ? '+' : ''}${quote.changePercent.toFixed(2)}%</span>`;
              node.className = `meta pct ${isPositive ? 'up' : 'down'}`;
            }
          }
        } catch (e) {
          console.warn(`Failed to update watchlist quote for ${ticker}:`, e);
        }
      }
    }

    // Make refresh function global
    window.refreshAllData = refreshAllData;
    
    // Open article function
    function openArticle(url) {
      console.log('=== OPENING ARTICLE ===');
      console.log('URL received:', url);
      console.log('URL type:', typeof url);
      console.log('URL length:', url ? url.length : 'null');
      
      if (url && url !== 'undefined' && url !== 'null' && url.startsWith('http')) {
        console.log('Opening URL in new tab:', url);
        window.open(url, '_blank', 'noopener,noreferrer');
      } else {
        console.error('Invalid URL:', url);
        alert('Invalid URL: ' + url);
      }
    }
    window.openArticle = openArticle;
    
    // Auto-refresh functionality - unified system
    let refreshIntervals = {
      news: null,
      scanner: null,
      health: null
    };
    
    function startAutoRefresh() {
      // Clear existing intervals
      if (refreshIntervals.news) clearInterval(refreshIntervals.news);
      if (refreshIntervals.scanner) clearInterval(refreshIntervals.scanner);
      if (refreshIntervals.health) clearInterval(refreshIntervals.health);
      
      // Start news auto-refresh (every 30 seconds)
      refreshIntervals.news = setInterval(() => {
        console.log('Auto-refreshing news...');
        fetchData();
      }, 30000);
      
      // Start scanner auto-refresh (every 45 seconds)
      refreshIntervals.scanner = setInterval(() => {
        console.log('Auto-refreshing scanner...');
        buildScanners();
      }, 45000);
      
      // Start health status updates (every 10 seconds)
      refreshIntervals.health = setInterval(() => {
        updateHealthStatus();
        updateProviderDiagnostics();
        
        // Load mini-charts for visible tickers
        loadMiniCharts();
      }, 10000);
      
      console.log('Auto-refresh started');
    }
    
    // Initialize new architecture
    async function initializeApp() {
      try {
        console.log('Initializing pro day-trader dashboard...');
        
        // Import modules
        const { appState } = await import('./src/state/store.js');
        const { StatusBar } = await import('./src/components/StatusBar.js');
        const { NewsFeed } = await import('./src/components/NewsFeed.js');
        const { wsQuotes } = await import('./src/ws/quotes.js');
        const { tickerResolver } = await import('./src/lib/tickers/resolve.js');
        const { scannerEngine } = await import('./src/lib/scanners/run.js');
        const { scannerScheduler } = await import('./src/lib/scanners/schedule.js');
        const { marketHours } = await import('./src/lib/time/marketHours.js');
        
        // Initialize status bar
        const statusBar = new StatusBar('status-bar');
        
        // Initialize news feed
        const newsFeed = new NewsFeed('news-feed');
        
        // Initialize WebSocket quotes with tick callback
        wsQuotes.setOnTickCallback((tick) => {
          console.log('Received tick:', tick.symbol, tick.price);
          // The tick is automatically added to the store by wsQuotes
        });
        
        // Load initial data
        await loadInitialData();
        
        // Start scanner scheduler (simplified)
        debugLog('Starting scanner scheduler...', 'info');
        setInterval(() => {
          buildScanners();
        }, 20000); // 20 second intervals
        
        // Start WebSocket connection (simplified)
        debugLog('Starting WebSocket connection...', 'info');
        try {
          const { wsQuotes } = await import('./src/ws/quotes.js');
          wsQuotes.setOnTickCallback((tick) => {
            debugLog(`Tick received: ${tick.symbol} @ $${tick.price}`, 'info');
          });
          await wsQuotes.connect();
          debugLog('WebSocket connected successfully', 'success');
        } catch (error) {
          debugLog(`WebSocket connection failed: ${error.message}`, 'error');
        }
        
        console.log('Dashboard initialized successfully');
        
        // Test environment variables via API
        console.log('=== Environment Variable Test ===');
        try {
          const envResponse = await fetch('/api/env');
          const envData = await envResponse.json();
          
          if (envData.success) {
            const envTest = {
              finnhub: !!envData.data.FINNHUB_KEY,
              fmp: !!envData.data.FMP_KEY,
              alphavantage: !!envData.data.ALPHAVANTAGE_KEY
            };
            console.log('API Keys Available:', envTest);
            console.log('Framework: Vanilla JS on Vercel');
            console.log('Config: Environment variables served via /api/env');
          } else {
            console.error('Failed to get environment variables:', envData.error);
          }
        } catch (error) {
          console.error('Environment variable test failed:', error);
        }
        console.log('===============================');
        
      } catch (error) {
        console.error('Failed to initialize dashboard:', error);
      }
    }
    
    // Load initial data
    async function loadInitialData() {
      debugLog('=== LOADING INITIAL DATA ===', 'info');
      
      // Create sample news data to test the UI
      const sampleNews = [
        {
          id: 'sample-1',
          title: 'Apple Reports Strong Q4 Earnings Beat',
          summary: 'Apple Inc. reported better-than-expected quarterly earnings with strong iPhone sales driving revenue growth.',
          url: 'https://example.com/apple-earnings',
          published_at: new Date().toISOString(),
          source: 'sample',
          symbols: ['AAPL'],
          sentiment: 'positive'
        },
        {
          id: 'sample-2', 
          title: 'Tesla Stock Surges on New Model Announcement',
          summary: 'Tesla shares jumped 8% after the company announced its new electric vehicle model with advanced features.',
          url: 'https://example.com/tesla-announcement',
          published_at: new Date().toISOString(),
          source: 'sample',
          symbols: ['TSLA'],
          sentiment: 'positive'
        },
        {
          id: 'sample-3',
          title: 'Microsoft Cloud Revenue Exceeds Expectations',
          summary: 'Microsoft reported strong cloud computing revenue growth, beating analyst estimates for the quarter.',
          url: 'https://example.com/microsoft-cloud',
          published_at: new Date().toISOString(),
          source: 'sample',
          symbols: ['MSFT'],
          sentiment: 'positive'
        }
      ];
      
      debugLog(`Using sample news data: ${sampleNews.length} items`, 'info');
      
      try {
        // Process sample news with ticker resolution
        const processedNews = [];
        for (const item of sampleNews) {
          let resolution;
          if (item.symbols && item.symbols.length > 0) {
            resolution = {
              ticker: item.symbols[0].toUpperCase(),
              confidence: 0.95,
              reason: 'provider'
            };
            debugLog(`Provider symbol found: ${item.symbols[0]} for "${item.title?.substring(0, 50)}..."`, 'success');
          } else {
            resolution = {
              ticker: null,
              confidence: 0,
              reason: 'no_symbol',
              isGeneral: true
            };
            debugLog(`No provider symbol for: "${item.title?.substring(0, 50)}..."`, 'warning');
          }
          
          processedNews.push({
            ...item,
            primaryTicker: resolution.ticker,
            confidence: resolution.confidence,
            isGeneral: resolution.isGeneral,
            tickerReason: resolution.reason
          });
        }
        
        debugLog(`Processed ${processedNews.length} news items`, 'success');
        
        // Update filtered news array
        newsData = processedNews;
        filteredNews = processedNews;
        
        debugLog('Rendering news...', 'info');
        // Render news immediately
        renderNews();
        
        // Try to load real news in background
        debugLog('Attempting to load real news in background...', 'info');
        try {
          const newsResponse = await fetch('/api/news?limit=50');
          if (newsResponse.ok) {
            const realNewsData = await newsResponse.json();
            if (realNewsData.success && realNewsData.data?.news?.length > 0) {
              const counts = realNewsData.data.meta?.counts || {};
              debugLog(`Real news loaded: ${realNewsData.data.news.length} items`, 'success');
              debugLog(`Provider counts: FMP=${counts.fmp || 0}, AV=${counts.alphavantage || 0}, FH=${counts.finnhub || 0}`, 'info');
              debugLog(`Errors: ${realNewsData.data.meta?.errors?.length || 0}`, 'info');
              
              // Replace sample data with real data
              newsData = realNewsData.data.news;
              filteredNews = realNewsData.data.news;
              renderNews();
            }
          }
        } catch (error) {
          debugLog(`Real news failed: ${error.message}`, 'warning');
        }
        
        // Start scanners immediately
        debugLog('Starting client-side scanners...', 'info');
        buildScanners();
        
      } catch (error) {
        debugLog(`Failed to load initial data: ${error.message}`, 'error');
        const feed = document.getElementById('news-feed');
        if (feed) {
          feed.innerHTML = `<div class="loading" style="color: #ff6b6b;">Error loading news: ${error.message}</div>`;
        }
      }
    }
    
    // Initialize mini-charts
    function initializeMiniCharts() {
      // Find all mini-chart containers and initialize them
      const miniCharts = document.querySelectorAll('.mini-chart[data-ticker]');
      miniCharts.forEach(chart => {
        const symbol = chart.dataset.ticker;
        if (symbol) {
          new MiniChart(chart, { symbol, range: '1d' });
        }
      });
    }
    
    // Initialize new architecture
    initializeApp();
    
    // Start auto-refresh
    startAutoRefresh();
    
    // Provider diagnostics function
    async function updateProviderDiagnostics() {
      try {
        const response = await fetch('/api/providers/diag');
        const data = await response.json();
        
        if (data.success) {
          const diag = data.data;
          const diagEl = document.getElementById('provider-diagnostics');
          
          if (diagEl) {
            const providerStatuses = Object.entries(diag.providers).map(([name, status]) => {
              const keyStatus = status.keyPresent ? '✓' : '✗';
              const healthStatus = status.status === 'healthy' ? '🟢' : 
                                 status.status === 'degraded' ? '🟡' : '🔴';
              return `${name.toUpperCase()}: ${keyStatus} ${healthStatus}`;
            }).join(' | ');
            
            diagEl.textContent = providerStatuses;
          }
        }
      } catch (error) {
        console.warn('Provider diagnostics update failed:', error);
        const diagEl = document.getElementById('provider-diagnostics');
        if (diagEl) {
          diagEl.textContent = 'Provider diagnostics unavailable';
        }
      }
    }

    // Load mini-charts for visible tickers
    async function loadMiniCharts() {
      const miniCharts = document.querySelectorAll('.mini-chart[data-ticker]');
      const tickers = Array.from(miniCharts).map(chart => chart.dataset.ticker);
      
      if (tickers.length === 0) return;
      
      try {
        // Mini-charts now use WebSocket tick data - no OHLC calls needed
        console.log('Mini-charts will use WebSocket tick data');
        
        // Mini-charts will be updated automatically via WebSocket tick data
        // No need for initial loading
      } catch (error) {
        console.warn('Mini-chart loading failed:', error);
      }
    }

    // Render mini-chart sparkline
    function renderMiniChart(container, ohlcData) {
      if (!ohlcData || ohlcData.length === 0) {
        container.innerHTML = '<div style="color: var(--meta); font-size: 0.7rem;">No data</div>';
        return;
      }
      
      const width = container.offsetWidth || 60;
      const height = container.offsetHeight || 20;
      
      // Calculate price range
      const prices = ohlcData.map(d => d.close);
      const minPrice = Math.min(...prices);
      const maxPrice = Math.max(...prices);
      const priceRange = maxPrice - minPrice;
      
      if (priceRange === 0) {
        container.innerHTML = '<div style="color: var(--meta); font-size: 0.7rem;">Flat</div>';
        return;
      }
      
      // Create SVG
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.style.overflow = 'visible';
      
      // Create path
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      const points = ohlcData.map((d, i) => {
        const x = (i / (ohlcData.length - 1)) * width;
        const y = height - ((d.close - minPrice) / priceRange) * height;
        return `${i === 0 ? 'M' : 'L'} ${x} ${y}`;
      }).join(' ');
      
      path.setAttribute('d', points);
      path.setAttribute('stroke', 'var(--accent)');
      path.setAttribute('stroke-width', '1');
      path.setAttribute('fill', 'none');
      
      svg.appendChild(path);
      container.innerHTML = '';
      container.appendChild(svg);
    }

    // Health status function
    async function updateHealthStatus() {
      try {
        const response = await fetch('/api/health');
        const data = await response.json();
        
        if (data.success) {
          const health = data.data;
          updateHealthPanel(health);
        }
      } catch (error) {
        console.warn('Health status update failed:', error);
      }
    }
    
    // Update health panel
    function updateHealthPanel(health) {
      const newsStatus = health.overall.status === 'healthy' ? 'LIVE' : 
                        health.overall.status === 'degraded' ? 'DEGRADED' : 'OFFLINE';
      const scannerStatus = health.overall.status === 'healthy' ? 'LIVE' : 
                           health.overall.status === 'degraded' ? 'DEGRADED' : 'OFFLINE';
      const symbolsStatus = health.symbols.active > 0 ? 'LIVE' : 'OFFLINE';
      
      // Update status indicators
      const statusElements = document.querySelectorAll('.status-indicator');
      statusElements.forEach(el => {
        const type = el.dataset.type;
        let status = 'OFFLINE';
        
        if (type === 'news') status = newsStatus;
        else if (type === 'scanner') status = scannerStatus;
        else if (type === 'symbols') status = symbolsStatus;
        
        el.textContent = status;
        el.className = `status-indicator ${status.toLowerCase()}`;
      });
    }
  </script>
</body>
</html>
